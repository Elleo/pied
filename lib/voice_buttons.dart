import 'dart:io';
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:path/path.dart' as path;
import 'delete_dialog.dart';
import 'download_manager.dart';
import 'info_dialog.dart';
import 'templates.dart';
import 'utils.dart';
import 'confirmation_dialog.dart';

class VoiceButtons extends StatefulWidget {
  const VoiceButtons(
      {super.key,
      required this.voiceId,
      required this.voiceData,
      required this.currentVoice,
      required this.currentSubVoice,
      required this.selectedSubVoice,
      required this.downloadedModels,
      required this.downloadManager,
      required this.onDownloadComplete,
      required this.onCurrentVoiceChanged,
      required this.onCurrentSubVoiceChanged});
  final String voiceId;
  final String currentVoice;
  final int currentSubVoice;
  final int selectedSubVoice;
  final List<dynamic> voiceData;
  final List<String> downloadedModels;
  final DownloadManager downloadManager;
  final VoidCallback onDownloadComplete;
  final ValueChanged<String> onCurrentVoiceChanged;
  final ValueChanged<int> onCurrentSubVoiceChanged;

  @override
  State<VoiceButtons> createState() => _VoiceButtonsState();
}

class _VoiceButtonsState extends State<VoiceButtons> {
  void restartSD() {
    if (isFlatpak()) {
      Process.runSync(
          "flatpak-spawn", ["--host", "killall", "speech-dispatcher"]);
    } else {
      Process.runSync("killall", ["speech-dispatcher"]);
    }
  }

  Future<void> setSDConfig() async {
    Directory confDir =
        Directory(path.join(getHome()!, ".config/speech-dispatcher"));
    
    // Ensure the main config directory and subdirectories exist
    if (!confDir.existsSync()) {
      confDir.createSync(recursive: true);
    }
    Directory modulesDir = Directory(path.join(confDir.path, "modules"));
    if (!modulesDir.existsSync()) {
      modulesDir.createSync(recursive: true);
    }
    Directory clientsDir = Directory(path.join(confDir.path, "clients"));
    if (!clientsDir.existsSync()) {
      clientsDir.createSync(recursive: true);
    }

    File sdConfig = File(path.join(confDir.path, "speechd.conf"));
    File piperConfig = File(path.join(modulesDir.path, "piper.conf"));

    DateTime now = DateTime.now();
    String timestamp =
        "${now.year}-${now.month}-${now.day}-${now.hour}-${now.minute}-${now.second}";
    
    File? sdBackup;
    File? piperBackup;
    bool sdChanged = false;

    // Check/Backup speechd.conf
    // If it exists and DOES NOT contain our signature, back it up.
    if (sdConfig.existsSync()) {
      if (!sdConfig.readAsStringSync().contains("THIS CONFIG WAS GENERATED BY PIED")) {
        sdBackup = File("${sdConfig.path}.bak-$timestamp");
        sdConfig.renameSync(sdBackup.path);
        
        // We only create new config if we moved the old one or it didn't exist
        sdConfig.createSync();
        sdConfig.writeAsString(sdConfigTemplate);
        sdChanged = true;
      }
    } else {
      // Create fresh if didn't exist
      sdConfig.createSync();
      sdConfig.writeAsString(sdConfigTemplate);
      sdChanged = true;
    }

    // if not generated by pied -> back up
    if (piperConfig.existsSync()) {
      if (!piperConfig.readAsStringSync().contains("THIS CONFIG WAS GENERATED BY PIED")) {
        piperBackup = File("${piperConfig.path}.bak-$timestamp");
        piperConfig.renameSync(piperBackup.path);
      }
    }

    // if changed config -> ask for confirmation
    if (sdChanged) {
      restartSD();
      Timer(const Duration(seconds: 2), () {
        confirmConfigChange(sdBackup, piperBackup);
      });
    }
  }

  Future<void> revertConfig(File? sdBackup, File? piperBackup) async {
    Directory confDir =
        Directory(path.join(getHome()!, ".config/speech-dispatcher"));
    File sdConfig = File(path.join(confDir.path, "speechd.conf"));
    File piperConfig = File(path.join(confDir.path, "modules/piper.conf"));

    // undo the Pied configuration
    if (sdConfig.existsSync()) {
      sdConfig.deleteSync();
    }
    if (piperConfig.existsSync()) {
      piperConfig.deleteSync();
    }

    // restore backups
    if (sdBackup != null && sdBackup.existsSync()) {
      sdBackup.renameSync(sdConfig.path);
    }
    if (piperBackup != null && piperBackup.existsSync()) {
      piperBackup.renameSync(piperConfig.path);
    }

    widget.onCurrentVoiceChanged("");
    restartSD();
    
    Timer(const Duration(seconds: 2), () {
      showDialog<void>(
          context: context,
          barrierDismissible: false,
          builder: (BuildContext context) {
            return Semantics(
                label:
                    'Your previous speech dispatcher configuration has now been reinstated.',
                enabled: true,
                container: true,
                child: AlertDialog(
                    title:
                        const Text('Speech Dispatcher Configuration Reverted'),
                    content: const SingleChildScrollView(
                      child: ListBody(
                        children: <Widget>[
                          Text(
                              'Your previous speech dispatcher configuration has now been reinstated.')
                        ],
                      ),
                    ),
                    actions: <Widget>[
                      TextButton(
                        autofocus: true,
                        onPressed: () {
                          Navigator.of(context).pop();
                        },
                        child: const Text('Okay'),
                      ),
                    ]));
          });
    });
  }

  Future<void> confirmConfigChange(File? sdBackup, File? piperBackup) async {
    return showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return ConfirmationDialog(onRevert: () {
            revertConfig(sdBackup, piperBackup);
          });
        });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        widget.downloadedModels.contains(widget.voiceData[4])
            ? widget.currentVoice == widget.voiceData[4] &&
                    widget.currentSubVoice == widget.selectedSubVoice
                ? const SizedBox(
                    height: 20, width: 99, child: Text("Current Voice"))
                : Semantics(
                    label: "Select ${widget.voiceId} voice",
                    enabled: true,
                    child: ElevatedButton(
                        onPressed: () async {
                          await setSDConfig();
                          
                          final Directory appDir = await getDataDir();
                          Directory modelDir =
                              Directory(path.join(appDir.path, "models"));
                          File modelConf = File(path.join(getHome()!,
                              ".config/speech-dispatcher/modules/piper.conf"));
                          
                          String configString = modelTemplate;
                          configString = configString.replaceAll("PIPER_PATH",
                              path.join(appDir.path, "piper", "piper"));
                          configString = configString.replaceAll("MODEL_PATH",
                              path.join(modelDir.path, widget.voiceData[4]));
                          configString = configString.replaceAll(
                              "SAMPLE_RATE", widget.voiceData[0]);
                          configString = configString.replaceAll(
                              "LANGUAGE", widget.voiceData[1]);
                          configString = configString.replaceAll(
                              "SUBVOICE", widget.selectedSubVoice.toString());
                          
                          String header = "# THIS CONFIG WAS GENERATED BY PIED\n";
                          
                          if (!modelConf.parent.existsSync()) {
                             modelConf.parent.createSync(recursive: true);
                          }
                          
                          // add pied signature to piper.conf
                          modelConf.writeAsString(header + configString);
                          restartSD();
                          widget.onCurrentVoiceChanged(widget.voiceData[4]);
                          widget.onCurrentSubVoiceChanged(
                              widget.selectedSubVoice);
                        },
                        child: const Text("Select Voice")))
            : ValueListenableBuilder<double?>(
                valueListenable: widget.downloadManager.progressNotifier,
                builder: (context, progress, child) {
                  if (progress != null) {
                    return SizedBox(
                        height: 20,
                        width: 94,
                        child: LinearProgressIndicator(value: progress));
                  } else {
                    return Semantics(
                        label: "Download $widget.voiceId voice",
                        enabled: true,
                        child: ElevatedButton(
                          child: const Text("Download"),
                          onPressed: () async {
                            String? downloadUrl = widget.voiceData[2];
                            String? downloadMetaUrl = widget.voiceData[3];
                            final Directory appDir = await getDataDir();
                            Directory modelDir =
                                Directory(path.join(appDir.path, "models"));
                            widget.downloadManager.download(
                                downloadMetaUrl!,
                                File(
                                    "${modelDir.path}/${widget.voiceData[4]}.json"),
                                () {});
                            widget.downloadManager.download(downloadUrl!,
                                File("${modelDir.path}/${widget.voiceData[4]}"),
                                () async {
                              setState(() {
                                widget.downloadedModels
                                    .add(widget.voiceData[4]);
                              });
                              widget.onDownloadComplete();
                            });
                          },
                        ));
                  }
                }),
        const SizedBox(width: 10),
        widget.voiceData[6] == ""
            ? const SizedBox()
            : Semantics(
                label: "Information about ${widget.voiceId}",
                enabled: true,
                child: IconButton(
                    icon: const Icon(Icons.info),
                    onPressed: () {
                      showDialog<void>(
                          context: context,
                          barrierDismissible: false,
                          builder: (BuildContext context) {
                            return InfoDialog(
                              modelName: widget.voiceId,
                              infoUri: Uri.parse(widget.voiceData[6]),
                            );
                          });
                    })),
        widget.downloadedModels.contains(widget.voiceData[4]) &&
                widget.currentVoice != widget.voiceData[4]
            ? Semantics(
                label: "Delete ${widget.voiceId}",
                enabled: true,
                child: IconButton(
                    icon: const Icon(Icons.delete),
                    onPressed: () async {
                      showDialog<void>(
                          context: context,
                          barrierDismissible: false,
                          builder: (BuildContext context) {
                            return DeleteDialog(onDelete: () async {
                              final Directory appDir = await getDataDir();
                              Directory modelDir =
                                  Directory(path.join(appDir.path, "models"));
                              File("${modelDir.path}/${widget.voiceData[4]}.json")
                                  .delete();
                              File("${modelDir.path}/${widget.voiceData[4]}")
                                  .delete();
                              setState(() {
                                widget.downloadedModels
                                    .remove(widget.voiceData[4]);
                              });
                            });
                          });
                    }))
            : const SizedBox(width: 34)
      ],
    );
  }
}
