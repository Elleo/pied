import 'dart:io';
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:path/path.dart' as path;
import 'delete_dialog.dart';
import 'download_manager.dart';
import 'info_dialog.dart';
import 'templates.dart';
import 'utils.dart';
import 'confirmation_dialog.dart';

class VoiceButtons extends StatefulWidget {
  const VoiceButtons(
      {super.key,
      required this.voiceId,
      required this.voiceData,
      required this.currentVoice,
      required this.currentSubVoice,
      required this.selectedSubVoice,
      required this.downloadedModels,
      required this.downloadManager,
      required this.onDownloadComplete,
      required this.onCurrentVoiceChanged,
      required this.onCurrentSubVoiceChanged});
  final String voiceId;
  final String currentVoice;
  final int currentSubVoice;
  final int selectedSubVoice;
  final List<dynamic> voiceData;
  final List<String> downloadedModels;
  final DownloadManager downloadManager;
  final VoidCallback onDownloadComplete;
  final ValueChanged<String> onCurrentVoiceChanged;
  final ValueChanged<int> onCurrentSubVoiceChanged;

  @override
  State<VoiceButtons> createState() => _VoiceButtonsState();
}

class _VoiceButtonsState extends State<VoiceButtons> {
  void restartSD() {
    if (isFlatpak()) {
      Process.runSync(
          "flatpak-spawn", ["--host", "killall", "speech-dispatcher"]);
    } else {
      Process.runSync("killall", ["speech-dispatcher"]);
    }
  }

  void setSDConfig() async {
    Directory confDir =
        Directory(path.join(getHome()!, ".config/speech-dispatcher"));
    Directory? originalConfigDir;
    if (confDir.existsSync()) {
      File sdConfig = File(path.join(confDir.path, "speechd.conf"));
      if (sdConfig.existsSync()) {
        if (sdConfig
            .readAsStringSync()
            .contains("THIS CONFIG WAS GENERATED BY PIED")) {
          return;
        }
      }
      DateTime now = DateTime.now();
      Directory newDir;
      if (isSnap()) {
        Directory origDir =
            Directory(path.join(getHome()!, ".config/speech-dispatcher.orig"));
        if (!origDir.existsSync()) {
          origDir.createSync();
        }
        newDir = Directory(
            "${confDir.path}.orig/${now.year}-${now.month}-${now.day}");
      } else {
        newDir = Directory(
            "${confDir.path}.orig.${now.year}-${now.month}-${now.day}");
      }
      if (newDir.existsSync()) {
        newDir.deleteSync(recursive: true);
      }
      confDir.renameSync(newDir.path);
      originalConfigDir = newDir;
    }
    confDir.createSync();
    Directory(path.join(confDir.path, "clients")).create();
    Directory(path.join(confDir.path, "modules")).create();
    File sdConfig = File(path.join(confDir.path, "speechd.conf"));
    sdConfig.createSync();
    sdConfig.writeAsString(sdConfigTemplate);
    restartSD();
    Timer(const Duration(seconds: 2), () {
      confirmConfigChange(originalConfigDir);
    });
  }

  Future<void> revertConfig(Directory? originalConfigDir) async {
    Directory confDir =
        Directory(path.join(getHome()!, ".config/speech-dispatcher"));
    confDir.deleteSync(recursive: true);
    if (originalConfigDir != null) {
      originalConfigDir.rename(confDir.path);
    }
    widget.onCurrentVoiceChanged("");
    restartSD();
    Timer(const Duration(seconds: 2), () {
      showDialog<void>(
          context: context,
          barrierDismissible: false,
          builder: (BuildContext context) {
            return Semantics(
                label:
                    'Your previous speech dispatcher configuration has now been reinstated.',
                enabled: true,
                container: true,
                child: AlertDialog(
                    title:
                        const Text('Speech Dispatcher Configuration Reverted'),
                    content: const SingleChildScrollView(
                      child: ListBody(
                        children: <Widget>[
                          Text(
                              'Your previous speech dispatcher configuration has now been reinstated.')
                        ],
                      ),
                    ),
                    actions: <Widget>[
                      TextButton(
                        autofocus: true,
                        onPressed: () {
                          Navigator.of(context).pop();
                        },
                        child: const Text('Okay'),
                      ),
                    ]));
          });
    });
  }

  Future<void> confirmConfigChange(Directory? originalConfigDir) async {
    return showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return ConfirmationDialog(onRevert: () {
            revertConfig(originalConfigDir);
          });
        });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        widget.downloadedModels.contains(widget.voiceData[4])
            ? widget.currentVoice == widget.voiceData[4] &&
                    widget.currentSubVoice == widget.selectedSubVoice
                ? const SizedBox(
                    height: 20, width: 99, child: Text("Current Voice"))
                : Semantics(
                    label: "Select ${widget.voiceId} voice",
                    enabled: true,
                    child: ElevatedButton(
                        onPressed: () async {
                          setSDConfig();
                          final Directory appDir = await getDataDir();
                          Directory modelDir =
                              Directory(path.join(appDir.path, "models"));
                          File modelConf = File(path.join(getHome()!,
                              ".config/speech-dispatcher/modules/piper.conf"));
                          String configString = modelTemplate;
                          configString = configString.replaceAll("PIPER_PATH",
                              path.join(appDir.path, "piper", "piper"));
                          configString = configString.replaceAll("MODEL_PATH",
                              path.join(modelDir.path, widget.voiceData[4]));
                          configString = configString.replaceAll(
                              "SAMPLE_RATE", widget.voiceData[0]);
                          configString = configString.replaceAll(
                              "LANGUAGE", widget.voiceData[1]);
                          configString = configString.replaceAll(
                              "SUBVOICE", widget.selectedSubVoice.toString());
                          modelConf.writeAsString(configString);
                          restartSD();
                          widget.onCurrentVoiceChanged(widget.voiceData[4]);
                          widget.onCurrentSubVoiceChanged(
                              widget.selectedSubVoice);
                        },
                        child: const Text("Select Voice")))
            : ValueListenableBuilder<double?>(
                valueListenable: widget.downloadManager.progressNotifier,
                builder: (context, progress, child) {
                  if (progress != null) {
                    return SizedBox(
                        height: 20,
                        width: 94,
                        child: LinearProgressIndicator(value: progress));
                  } else {
                    return Semantics(
                        label: "Download $widget.voiceId voice",
                        enabled: true,
                        child: ElevatedButton(
                          child: const Text("Download"),
                          onPressed: () async {
                            String? downloadUrl = widget.voiceData[2];
                            String? downloadMetaUrl = widget.voiceData[3];
                            final Directory appDir = await getDataDir();
                            Directory modelDir =
                                Directory(path.join(appDir.path, "models"));
                            widget.downloadManager.download(
                                downloadMetaUrl!,
                                File(
                                    "${modelDir.path}/${widget.voiceData[4]}.json"),
                                () {});
                            widget.downloadManager.download(downloadUrl!,
                                File("${modelDir.path}/${widget.voiceData[4]}"),
                                () async {
                              setState(() {
                                widget.downloadedModels
                                    .add(widget.voiceData[4]);
                              });
                              widget.onDownloadComplete();
                            });
                          },
                        ));
                  }
                }),
        const SizedBox(width: 10),
        widget.voiceData[6] == ""
            ? const SizedBox()
            : Semantics(
                label: "Information about ${widget.voiceId}",
                enabled: true,
                child: IconButton(
                    icon: const Icon(Icons.info),
                    onPressed: () {
                      showDialog<void>(
                          context: context,
                          barrierDismissible: false,
                          builder: (BuildContext context) {
                            return InfoDialog(
                              modelName: widget.voiceId,
                              infoUri: Uri.parse(widget.voiceData[6]),
                            );
                          });
                    })),
        widget.downloadedModels.contains(widget.voiceData[4]) &&
                widget.currentVoice != widget.voiceData[4]
            ? Semantics(
                label: "Delete ${widget.voiceId}",
                enabled: true,
                child: IconButton(
                    icon: const Icon(Icons.delete),
                    onPressed: () async {
                      showDialog<void>(
                          context: context,
                          barrierDismissible: false,
                          builder: (BuildContext context) {
                            return DeleteDialog(onDelete: () async {
                              final Directory appDir = await getDataDir();
                              Directory modelDir =
                                  Directory(path.join(appDir.path, "models"));
                              File("${modelDir.path}/${widget.voiceData[4]}.json")
                                  .delete();
                              File("${modelDir.path}/${widget.voiceData[4]}")
                                  .delete();
                              setState(() {
                                widget.downloadedModels
                                    .remove(widget.voiceData[4]);
                              });
                            });
                          });
                    }))
            : const SizedBox(width: 34)
      ],
    );
  }
}
